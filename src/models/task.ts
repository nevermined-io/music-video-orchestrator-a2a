/**
 * @file task.ts
 * @description Type definitions for task-related entities
 */

/**
 * @enum TaskState
 * @description Possible states of a task
 */
export enum TaskState {
  SUBMITTED = "submitted",
  WORKING = "working",
  INPUT_REQUIRED = "input-required",
  COMPLETED = "completed",
  CANCELED = "canceled",
  FAILED = "failed",
  REJECTED = "rejected",
  AUTH_REQUIRED = "auth-required",
  UNKNOWN = "unknown",
}

/**
 * @interface Task
 * @description Represents a task in the system
 */
export interface Task {
  // A unique identifier for the task. This ID is generated by the server.
  // It should be sufficiently unique (e.g., a UUID v4).
  id: string;
  // Server-generated id for contextual alignment across interactions
  // Useful for maintaining context across multiple, sequential, or related tasks.
  contextId: string;
  // The current status of the task, including its lifecycle state, an optional associated message,
  // and a timestamp.
  status: TaskStatus;
  // An array of outputs (artifacts) generated by the agent for this task.
  // This array can be populated incrementally, especially during streaming.
  // Artifacts represent the tangible results of the task.
  artifacts?: Artifact[];
  // An optional array of recent messages exchanged within this task,
  // ordered chronologically (oldest first).
  // This history is included if requested by the client via the `historyLength` parameter
  // in `TaskSendParams` or `TaskQueryParams`.
  history?: Message[];
  // Arbitrary key-value metadata associated with the task.
  // Keys SHOULD be strings; values can be any valid JSON type (string, number, boolean, array, object).
  // This can be used for application-specific data, tracing info, etc.
  metadata?: Record<string, any>;
}

export interface TaskStatus {
  // The current lifecycle state of the task.
  state: TaskState;
  // An optional message associated with the current status.
  // This could be a progress update from the agent, a prompt for more input,
  // a summary of the final result, or an error message.
  message?: Message;
  // The date and time (UTC is STRONGLY recommended) when this status was recorded by the server.
  // Format: ISO 8601 `date-time` string (e.g., "2023-10-27T10:00:00Z").
  timestamp?: string;
}

export interface Message {
  // Indicates the sender of the message:
  // "user" for messages originating from the A2A Client (acting on behalf of an end-user or system).
  // "agent" for messages originating from the A2A Server (the remote agent).
  role: "user" | "agent";
  // An array containing the content of the message, broken down into one or more parts.
  // A message MUST contain at least one part.
  // Using multiple parts allows for rich, multi-modal content (e.g., text accompanying an image).
  parts: Part[];
  // Arbitrary key-value metadata associated with the message.
  // Keys SHOULD be strings; values can be any valid JSON type.
  // Useful for timestamps, source identifiers, language codes, etc.
  metadata?: Record<string, any>;
  // List of tasks referenced as contextual hint by this message.
  referenceTaskIds?: string[];
  // message identifier created by the message creator
  messageId: string;
  // task identifier the current message is related to
  taskId?: string;
  // Context identifier the message is associated with
  contextId?: string;
  // type discriminator
  kind: "message";
}

export type Part = TextPart | FilePart | DataPart;

export interface TextPart {
  kind: "text"; // Discriminator
  text: string; // The actual textual content.
  metadata?: Record<string, any>; // Optional metadata (e.g., language, formatting hints if any)
}

export interface FilePart {
  kind: "file"; // Discriminator
  file: FileWithBytes | FileWithUri; // Contains the file details and data (or reference).
  metadata?: Record<string, any>; // Optional metadata (e.g., purpose of the file)
}

export interface DataPart {
  kind: "data"; // Discriminator
  // The structured JSON data payload. This can be any valid JSON object.
  // The schema of this data is application-defined and may be implicitly understood
  // by the interacting agents or explicitly described (e.g., via a JSON Schema reference
  // in the `metadata` or associated `AgentSkill`).
  data: Record<string, any>;
  metadata?: Record<string, any>; // Optional metadata (e.g., schema URL, version)
}

export interface FileWithBytes {
  // The original filename, if known (e.g., "document.pdf", "avatar.png").
  name?: string;
  // The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
  // of the file (e.g., "application/pdf", "image/png"). Strongly recommended for proper handling.
  mimeType?: string;
  // Base64 encoded string of the raw file content.
  // Use this for embedding small to medium-sized files directly.
  bytes: string; // Base64 string
}

export interface FileWithUri {
  // The original filename, if known (e.g., "document.pdf", "avatar.png").
  name?: string;
  // The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
  // of the file (e.g., "application/pdf", "image/png"). Strongly recommended for proper handling.
  mimeType?: string;
  // URI for the file.
  uri: string; // Base64 string
}

export interface Artifact {
  //unique identifier for the artifact generated by the agent. This identifier helps identify and assemble parts streamed by the agent
  artifactId: string;
  // A descriptive name for the artifact (e.g., "Quarterly Sales Report.pdf", "Generated Logo Design", "analysis_results.json").
  // This name might be used by the client for display or identification.
  name?: string;
  // A human-readable description of the artifact. [CommonMark](https://commonmark.org/) MAY be used.
  description?: string;
  // An array containing the content of the artifact, broken down into one or more parts.
  // An artifact MUST contain at least one part.
  // Using multiple parts allows for complex artifacts (e.g., a report with embedded images or data tables).
  parts: Part[];
  // Arbitrary key-value metadata associated with the artifact.
  // Keys SHOULD be strings; values can be any valid JSON type.
  // Useful for creation timestamps, versioning info, checksums, etc.
  metadata?: Record<string, any> | null;
}
